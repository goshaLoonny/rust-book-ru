## Привет, Cargo!

Cargo — это система сборки и менеджер пакетов для Rust. Большинство растасеан (Rustaceans) используют этот инструмент для управления своими проектами на Rust, потому что Cargo берёт на себя множество задач: компиляцию кода, загрузку библиотек, от которых зависит ваш код, и сборку этих библиотек. (Такие библиотеки называются _зависимостями_.)

Простейшие программы на Rust, как та, что мы написали ранее, не имеют зависимостей. Если бы мы создавали проект “Hello, world!” с помощью Cargo, он бы использовал только ту часть Cargo, которая отвечает за компиляцию кода. Но по мере усложнения программ вы будете добавлять зависимости, и если начать проект с Cargo, добавлять зависимости будет намного проще.

Поскольку подавляющее большинство проектов на Rust используют Cargo, мы предполагаем, что вы тоже будете использовать его. Cargo устанавливается вместе с Rust, если вы воспользовались официальным установщиком, о котором говорилось в разделе [«Установка»][installation]<!-- ignore -->. Если вы устанавливали Rust другим способом, проверьте наличие Cargo, введя в терминале:

```console
$ cargo --version
```

Если вы видите номер версии — отлично! Если появляется ошибка, например `command not found`, обратитесь к документации по способу установки, чтобы узнать, как установить Cargo отдельно.

### Создание проекта с помощью Cargo

Создадим новый проект с помощью Cargo и посмотрим, чем он отличается от нашей первой версии “Hello, world!”. Перейдите в директорию _projects_ (или куда вы сохраняете свои проекты). Затем выполните:

```console
$ cargo new hello_cargo
$ cd hello_cargo
```

Первая команда создаёт новую директорию и проект с именем _hello_cargo_. Мы дали проекту имя _hello_cargo_, и Cargo создал файлы в директории с таким же названием.

Перейдите в директорию _hello_cargo_ и посмотрите её содержимое. Вы увидите, что Cargo создал для нас два файла и одну директорию: файл _Cargo.toml_ и директорию _src_ с файлом _main.rs_ внутри.

Также инициализирован новый Git-репозиторий с файлом _.gitignore_. Git-файлы не создаются, если вы запускаете `cargo new` внутри уже существующего репозитория; это поведение можно изменить, указав `cargo new --vcs=git`.

> Примечание: Git — это популярная система контроля версий. Вы можете указать другую систему или вовсе отказаться от неё с помощью флага `--vcs`. Выполните `cargo new --help`, чтобы увидеть доступные варианты.

Откройте _Cargo.toml_ в редакторе. Он должен выглядеть примерно так, как показано в листинге 1-2.

<Листинг 1-2, имя файла="Cargo.toml", подпись="Содержимое *Cargo.toml*, сгенерированного командой `cargo new`">

```toml
[package]
name = "hello_cargo"
version = "0.1.0"
edition = "2024"

[dependencies]
```

</Листинг>

Этот файл использует формат [_TOML_][toml]<!-- ignore --> (_Tom’s Obvious, Minimal Language_), который используется для конфигурации Cargo.

Первая строка, `[package]`, указывает начало секции, где задаются параметры пакета. В дальнейшем мы добавим другие секции.

Следующие три строки задают параметры, необходимые Cargo для компиляции вашей программы: имя, версию и версию редакции Rust. О ключе `edition` подробнее рассказано в [Приложении E][appendix-e]<!-- ignore -->.

Последняя строка, `[dependencies]`, начинает секцию, где указываются зависимости проекта. В Rust пакеты кода называются _crates_. Для этого проекта зависимости не нужны, но в первом проекте второй главы мы их добавим.

Теперь откройте _src/main.rs_:

<span class="filename">Имя файла: src/main.rs</span>

```rust
fn main() {
    println!("Hello, world!");
}
```

Cargo уже сгенерировал для вас программу “Hello, world!”, аналогичную той, что мы писали в листинге 1-1. Основные отличия в том, что Cargo разместил код в директории _src_ и создал файл конфигурации _Cargo.toml_ в корневой директории проекта.

Cargo ожидает, что исходные файлы будут находиться внутри _src_. Корневая директория проекта предназначена для README-файлов, лицензий, конфигураций и других служебных данных. Использование Cargo помогает поддерживать порядок в проекте.

Если вы начали писать проект без Cargo, как мы делали в “Hello, world!”, вы можете конвертировать его. Переместите код в директорию _src_ и создайте файл _Cargo.toml_. Самый простой способ — использовать команду `cargo init`, которая сделает это за вас.

### Сборка и запуск проекта Cargo

Теперь посмотрим, чем отличается сборка и запуск программы “Hello, world!” с помощью Cargo. Из директории _hello_cargo_ выполните команду:

```console
$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
```

Эта команда создаёт исполняемый файл в _target/debug/hello_cargo_ (или _target\debug\hello_cargo.exe_ на Windows), а не в текущей директории. Поскольку по умолчанию сборка — это отладочная версия, Cargo помещает бинарник в директорию _debug_. Запустить исполняемый файл можно командой:

```console
$ ./target/debug/hello_cargo # или .\target\debug\hello_cargo.exe на Windows
Hello, world!
```

Если всё прошло хорошо, в терминале вы увидите `Hello, world!`. Первая сборка также создаёт новый файл _Cargo.lock_ в корне проекта. Он фиксирует точные версии зависимостей. В этом проекте зависимостей нет, так что файл будет пустым. Вам не нужно редактировать его вручную — Cargo управляет им сам.

Мы только что собрали проект с помощью `cargo build` и запустили его вручную, но можно сделать это одной командой:

```console
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

`cargo run` удобнее, чем поочерёдно использовать `cargo build` и затем запускать бинарник по пути. Поэтому большинство разработчиков используют именно `cargo run`.

Обратите внимание, что теперь не отображается информация о компиляции — Cargo понял, что файлы не изменились, и просто запустил бинарник. Если бы вы изменили код, Cargo пересобрал бы проект:

```console
$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
```

Cargo также предлагает команду `cargo check`. Она быстро проверяет, что ваш код компилируется, но не создаёт исполняемый файл:

```console
$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
```

Зачем проверка без бинарника? Обычно `cargo check` работает быстрее, чем `cargo build`, потому что пропускает этап сборки. Если вы часто проверяете работоспособность кода в процессе написания, `cargo check` поможет делать это быстрее. Многие растасеане регулярно запускают `cargo check` при разработке, а `cargo build` — только для финальной сборки.

Подведём итоги того, что мы узнали о Cargo:

- Создавать проект можно с помощью `cargo new`.
- Собирать проект — через `cargo build`.
- Собирать и запускать в один шаг — через `cargo run`.
- Проверять компиляцию без создания бинарника — через `cargo check`.
- Результат сборки хранится в директории _target/debug_, а не рядом с кодом.

Дополнительное преимущество Cargo в том, что команды одинаковы на всех операционных системах. Поэтому далее мы не будем делать различий между Linux, macOS и Windows.

### Сборка релизной версии

Когда проект готов к выпуску, вы можете выполнить сборку с оптимизациями:

```console
$ cargo build --release
```

Эта команда создаст исполняемый файл в _target/release_ вместо _target/debug_. Оптимизации ускоряют работу программы, но удлиняют время компиляции. Поэтому существуют два профиля: для разработки (быстрая и частая сборка) и для релиза (максимальная скорость исполнения). Если вы измеряете производительность, обязательно используйте `cargo build --release` и запускайте исполняемый файл из _target/release_.

### Cargo как соглашение

В простых проектах Cargo не даёт большого преимущества по сравнению с `rustc`, но его польза возрастает с увеличением сложности. Когда появляется необходимость разбить код на несколько файлов или использовать зависимости, Cargo берёт управление сборкой на себя.

Хотя `hello_cargo` — это простой проект, он использует настоящий инструментарий, который вы будете применять на протяжении всей работы с Rust. Чтобы начать работу над существующим проектом, можно использовать следующие команды:

```console
$ git clone example.org/someproject
$ cd someproject
$ cargo build
```

Подробнее о Cargo — в [официальной документации][cargo].

## Итоги

Вы уже сделали отличный старт в изучении Rust! В этой главе вы узнали, как:

- Установить последнюю стабильную версию Rust с помощью `rustup`
- Обновить версию Rust
- Открыть локальную документацию
- Написать и запустить “Hello, world!” с использованием `rustc`
- Создать и запустить новый проект по соглашениям Cargo

Сейчас отличное время, чтобы создать более серьёзную программу и привыкнуть читать и писать код на Rust. В главе 2 мы создадим игру "Угадай число". Если вы хотите сначала изучить базовые программные концепции в Rust, переходите к главе 3, а затем возвращайтесь ко второй.

[installation]: ch01-01-installation.html#installation  
[toml]: https://toml.io  
[appendix-e]: appendix-05-editions.html  
[cargo]: https://doc.rust-lang.org/cargo/
